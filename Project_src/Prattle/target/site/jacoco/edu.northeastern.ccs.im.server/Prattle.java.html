<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Prattle.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Prattle</a> &gt; <a href="index.source.html" class="el_package">edu.northeastern.ccs.im.server</a> &gt; <span class="el_source">Prattle.java</span></div><h1>Prattle.java</h1><pre class="source lang-java linenums">package edu.northeastern.ccs.im.server;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

import edu.northeastern.ccs.im.Message;

/**
 * A network server that communicates with IM clients that connect to it. This
 * version of the server spawns a new thread to handle each client that connects
 * to it. At this point, messages are broadcast to all of the other clients.
 * It does not send a response when the user has gone off-line.
 * &lt;p&gt;
 * This work is licensed under the Creative Commons Attribution-ShareAlike 4.0
 * International License. To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-sa/4.0/. It is based on work
 * originally written by Matthew Hertz and has been adapted for use in a class
 * assignment at Northeastern University.
 *
 * @version 1.3
 */
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">public abstract class Prattle {</span>

    /* Logger */
<span class="fc" id="L38">    private static final Logger LOGGER = Logger.getLogger(Prattle.class.getName());</span>


    /* Amount of time we should wait for a signal to arrive. */
    private static final int DELAY_IN_MS = 50;

    /* Number of threads available in our thread pool. */
    private static final int THREAD_POOL_SIZE = 20;

    /* Delay between times the thread pool runs the client check. */
    private static final int CLIENT_CHECK_DELAY = 200;

    /* Collection of threads that are currently being used. */
    private static ConcurrentLinkedQueue&lt;ClientRunnable&gt; active;


    /* Socket on the appropriate port to which this server connects. */
    private static ServerSocketChannel serverSocket;

    /* All of the static initialization occurs in this &quot;method&quot; */
    static {
        // Create the new queue of active threads.
<span class="fc" id="L60">        active = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L61">    }</span>

    /**
     * Broadcast a given message to all the other IM clients currently on the
     * system. This message _will_ be sent to the client who originally sent it.
     *
     * @param message Message that the client sent.
     */
    public static void broadcastMessage(Message message) {
        // Loop through all of our active threads
<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (ClientRunnable tt : active) {</span>
            // Do not send the message to any clients that are not ready to receive it.
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">            if (tt.isInitialized()) {</span>
<span class="fc" id="L74">                tt.enqueueMessage(message);</span>
            }
<span class="fc" id="L76">        }</span>
<span class="fc" id="L77">    }</span>

    public static void directMessage(Message message, String client) {
        // Loop through all of our active threads
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for (ClientRunnable tt : active) {</span>
            // Do not send the message to any clients that are not ready to receive it.
<span class="pc bpc" id="L83" title="2 of 4 branches missed.">            if (tt.isInitialized() &amp;&amp; tt.getName().equals(client)) {</span>
<span class="nc" id="L84">                tt.enqueueMessage(message);</span>
            }
<span class="fc" id="L86">        }</span>
<span class="fc" id="L87">    }</span>

    /**
     * Start up the threaded talk server. This class accepts incoming connections on
     * a specific port specified on the command-line. Whenever it receives a new
     * connection, it will spawn a thread to perform all of the I/O with that
     * client. This class relies on the server not receiving too many requests -- it
     * does not include any code to limit the number of extant threads.
     *
     * @param args String arguments to the server from the command line. At present
     *             the only legal (and required) argument is the port on which this
     *             server should list.
     * @throws IOException Exception thrown if the server cannot connect to the port
     *                     to which it is supposed to listen.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void main(String[] args) throws IOException {
        // Connect to the socket on the appropriate port to which this server connects.
<span class="fc" id="L105">        serverSocket = ServerSocketChannel.open();</span>
<span class="fc" id="L106">        serverSocket.configureBlocking(false);</span>
<span class="fc" id="L107">        serverSocket.socket().bind(new InetSocketAddress(ServerConstants.PORT));</span>
        // Create the Selector with which our channel is registered.
<span class="fc" id="L109">        Selector selector = SelectorProvider.provider().openSelector();</span>
        // Register to receive any incoming connection messages.
<span class="fc" id="L111">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span>
        // Create our pool of threads on which we will execute.
<span class="fc" id="L113">        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(THREAD_POOL_SIZE);</span>
        // Listen on this port until ...
<span class="fc" id="L115">        boolean done = false;</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        while (!done) {</span>
            // Check if we have a valid incoming request, but limit the time we may wait.
<span class="fc bfc" id="L118" title="All 2 branches covered.">            while (selector.select(DELAY_IN_MS) != 0) {</span>
                // Get the list of keys that have arrived since our last check
<span class="fc" id="L120">                Set&lt;SelectionKey&gt; acceptKeys = selector.selectedKeys();</span>
                // Now iterate through all of the keys
<span class="fc" id="L122">                Iterator&lt;SelectionKey&gt; it = acceptKeys.iterator();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">                while (it.hasNext()) {</span>
                    // Get the next key; it had better be from a new incoming connection
<span class="fc" id="L125">                    SelectionKey key = it.next();</span>
<span class="fc" id="L126">                    it.remove();</span>
                    // Assert certain things I really hope is true
<span class="pc bpc" id="L128" title="2 of 4 branches missed.">                    assert key.isAcceptable();</span>
<span class="pc bpc" id="L129" title="2 of 4 branches missed.">                    assert key.channel() == serverSocket;</span>
                    // Create a new thread to handle the client for which we just received a
                    // request.
                    try {
                        // Accept the connection and create a new thread to handle this client.
<span class="fc" id="L134">                        SocketChannel socket = serverSocket.accept();</span>
                        // Make sure we have a connection to work with.
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">                        if (socket != null) {</span>
<span class="fc" id="L137">                            ClientRunnable tt = new ClientRunnable(socket);</span>
                            // Add the thread to the queue of active threads
<span class="fc" id="L139">                            active.add(tt);</span>
                            // Have the client executed by our pool of threads.
                            @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L142">                            ScheduledFuture clientFuture = threadPool.scheduleAtFixedRate(tt, CLIENT_CHECK_DELAY,</span>
                                    CLIENT_CHECK_DELAY, TimeUnit.MILLISECONDS);
<span class="fc" id="L144">                            tt.setFuture(clientFuture);</span>
                        }
<span class="nc" id="L146">                    } catch (AssertionError ae) {</span>
<span class="nc" id="L147">                        LOGGER.info(&quot;Caught Assertion: &quot; + ae.toString());</span>
<span class="nc" id="L148">                    } catch (Exception e) {</span>
<span class="nc" id="L149">                        LOGGER.info(&quot;Caught Exception: &quot; + e.toString());</span>
<span class="pc" id="L150">                    }</span>
<span class="fc" id="L151">                }</span>
<span class="fc" id="L152">            }</span>
        }
<span class="nc" id="L154">    }</span>


    /**
     * Remove the given IM client from the list of active threads.
     *
     * @param dead Thread which had been handling all the I/O for a client who has
     *             since quit.
     */
    public static void removeClient(ClientRunnable dead) {
        // Test and see if the thread was in our list of active clients so that we
        // can remove it.
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (!active.remove(dead)) {</span>
<span class="fc" id="L167">            LOGGER.info(&quot;Could not find a thread that I tried to remove!\n&quot;);</span>
        }
<span class="fc" id="L169">    }</span>

    public static ServerSocketChannel getServerSocket() {
<span class="fc" id="L172">        return serverSocket;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>